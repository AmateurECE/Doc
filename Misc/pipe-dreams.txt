###############################################################################
# NAME:		    pipe-dreams.txt
#
# AUTHOR:	    Ethan D. Twardy
#
# DESCRIPTION:	    Ideas for dumb projects that I'll probably never do.
#
# CREATED:	    09/11/2017
#
# LAST EDITED:	    10/12/2018
###

###############################################################################
# MATHEMATICS
###

*   Come up with a model to determine environmental effects on transistor beta.
*   Determine a mathematically accurate method for describing an algorithm.
    The purpose of this is to optimize and perfect interfaces and algorithms
    before translating them into source code. This has applications in
    scientific computing and operating systems research. I'm not convinced that
    I know the math yet to be able to do this, but we should be able to
    represent:
	- Algorithms and Data Structures BOTH as tuples, which have sets of
	inputs, sets of outputs, and functions which match inputs to outputs,
	as well as functions which relate the time and space complexity of
	the system.
	- The functions should be able to be represented in a common format
	which can be analyzed.
	- Data types of the inputs and outputs should be specified, but they
	should not be integral to the understanding of the system.
	- Pseudocode should NOT be necessary for understanding the system.
*   Research Linear Programming as a method for optimizing parallel computing.
*   Research using the discrete derivative of a vector of integers to determine
    the best algorithm to sort the vector. This will probably require examining
    the discrete derivative of the best and worst cases of many common types of
    sorting algorithms.
*   Determine the impulse response of solid state devices (i.e, the common
    silicon diode, bjt, and fet) using the laplace transform.
*   Perform Black-Box Design of the frequency-controlled voltage source, for
    the tuner project. In case I've forgotten by the time I get around to this,
    the tuner will light up one of several Red-Green LEDs to indicate the pitch
    of a signal generated by the standard noisy signal generator. The interface
    will have seven R/G LEDs, one for each of the seven common pitches. Here is
    an example: If the light 'A' is green, it means the pitch is akin to a
    musical 'A', or within a tolerable range. If both 'A' and 'B' are green,
    the pitch is A# (or B flat). Any combination of red lights indicates that
    the pitch is not within tolerable limits of any musical pitch. 

###############################################################################
# PROGRAMMING
###

*   Write an application that grabs your coordinates every time your radio
    plays a new song, then graphs your music choices and related metrics on a
    map, potentially using a Google Maps Rest API.
*   Complete a comparison of the three ambiguous size file reading techniques.
    In case you don't remember, here's a recap:
	1. Read each character, one at a time, with fgetc. Remember this can
	    be implemented slightly differently, as in the case of CS1142
	    Program 8, where I kept track of the current file size while
	    reading, and once at the end of the file, used fseek to return to
	    the front and read `size' + 1 bytes from the file, and store them
	    in a char array.
	2. Read bytes in bulk into a char array, using realloc whenever space
	    runs out.
	3. Read bytes in incrementally into a dynamic array. Specifically the
	    dynamic array implementation in C, on my Github.
    The goal will then be to write tests:
	- A time test, which will run each implemenation with the same inputs
	    an outrageous number of times, then remove outlier data and present
	    in a nice Gnuplot graph
	- A space test, which uses valgrind (or some other method) to determine
	    how much space was used overall by each implementation, and the
	    largest amount of space held by the program at any one time.
    Don't forget to tie all of this together with a makefile, and to run it on
    OS X and Linux systems!
*   Complete a paper on code micro-optimizations--optimal utilization of cache,
    instruction decomposition, etc, and especially as they apply to parallel
    code. Memory bandwidth reduction, (false-)sharing, prefetching. Draw
    similarities to micro-optimizations used to reduce memory footprint in
    older architectures. Research locality of reference (spatial and temporal).
    Temporal Locality Optimization Techniques:
	- Loop fusion, loop unrolling
	- tiling, blocking
*   C - Use the breadth-first search method (and a stack to eliminate contrary
    motion) to determine sub-algorithms which perform specific tranformations
    of the 4 x 4 x 4 puzzle cube. The cube could be represented as six 4 x 4
    matrices which contain enumerated values corresponding to the six colors.
    They should, however, not be enums. To save space, they should be arrays of
    single bytes which are aliased with preprocessor macros. This can be
    thought of as an n-ary tree corresponding to an NFA. The root node is a
    lambda transition (the only one) and each of it's 24 children correspond to
    a unique primitive transformation on the cube. A binary (flattened)
    representation will be used, so as to avoid muddling with the complexities
    of n-ary trees. This also means that a `pure breadth-first' search cannot
    be used. 
*   Fortran,C,Verilog - A constant time logarithm calculator (base 2).
*   Fortran,C - calculate the position of the stars in a constellation given a
    latitude, longitude, and date.
*   Fortran,C - A discrete Laplace transform.
*   Fortran,C - Determine a combination of resistors, capacitors, inductors, to
    achieve an exact or close approximation of an impedance.
*   Fortran,C - Program to convert an RC filter to an equivalent LC filter, and
    vice versa.
*   C - Create a parallel NFA with fork() and/or OpenMP.

###############################################################################
# ENGINEERING
###

* TIMED LAMP
* TENT LAMP
* PYTHON COMMON TRUMP WORDS
* FAKE TRUMP TWEETS
* DETERMINE IF A SENTENCE IS ENGLISH
* Notizen
* Autoscrum
* Midichlorian
* Tool to add/Remove symbols ad hoc; also visualize memory regions accessed
    in binary.

*   Hardware compiler
*   `Stutter' effect
*   Discrete NMOS log2 calculator
*   Automatic beer brewer, built literally from scratch
*   RTOS CAN logger for the Highlander
*   Mumbo Jumbo - Analog TV that visualizes analog signals (e.g. music) with
    white noise.
*   Embedded Hypervisor - An architecture that would support coprocessors which
    would be responsible for performing binary translation to and from the ISA
    of the pure metal core, essentially becoming a 'hardware hypervisor'. This
    coprocessor could be implemented as an FPGA.
*   Compact Cluster - A compact, loosely coupled computing cluster that uses
    dynamically replaceable mezzanine compute modules. These modules should
    have a common form factor--for example, (SO-)DIMM--as well as their own
    dedicated private memory, but the system will provide shared memory. The
    individual modules should be invisible to the user. The operating system
    will provide a relatively simple scripting interface that will allow for
    custom work queues, scheduling, and symmetric processing.
*   Capacitive virtual joystick - This idea needs some refining. The gist is
    that I would like a way to translate motion of the thumb into vector
    motion, with a simple program API, so that this `virtual joystick' can be
    used to control things such as mice, remote-controlled devices, etc. One
    theory is to use a pair of differential three-axis accelerometers to
    measure acceleration in one axis. The control would be momentary--i.e.
    acceleration in one direction would cause a vector in that direction, but
    the vector will persist after the acceleration goes to zero. The vector
    not be zeroed until an equal and opposite acceleration is experience.

###############################################################################
