###############################################################################
# NAME:		    features.txt
#
# AUTHOR:	    Ethan D. Twardy
#
# DESCRIPTION:	    Just a head-start on some of the things I want my board to
#		    do. Eventually this will become a LaTeX file.
#
# CREATED:	    12/11/2017
#
# LAST EDITED:	    02/14/2018
###

###############################################################################
# BOARD FEATURES
###

*   A switch, which will put the board into 'programming' mode. This mode will
    be used to program new images onto the board.

*   A jumper, which will determine whether the board boots from internal Flash
    memory or from external EEPROM. The value of this jumper will determine
    whether new images are programmed to internal Flash or EEPROM memory.

*   A jumper, which will enforce a hardware write-protect of the external
    EEPROM.

*   A jumper, which will remove the EEPROM from the system (?).

*   Ideally, a single micro-USB port, which will be used for serial
    communication and image programming.

*   Support for in-system programming.

*   SRAM (The CPU is too slow for SDRAM)

*   Ethernet (A CPU with a RMII interface is preferable)

*   Perhaps I should use this as a platform to begin developing my first
    multiprocessor system?

*   Microchip has a 2kb EEPROM which comes with a preprogrammed, globally
    unique MAC address. For the love of god, please short the write protect pin
    on this chip high. PERMANENTLY.

###############################################################################
# SOFTWARE FEATURES
###

*   Primitive second-stage bootloader which supports booting from EEPROM.

*   Drivers for all devices on the board.

*   POSTs (Power On Self Tests) for all devices on the board.

###############################################################################
# KERNEL FEATURES
###

*   The goal is to have paradigms similar to that of Linux. Linux works, and it
    works well, so don't try to reinvent the wheel for things that can be
    reused. Also, the more Linux-like it is, the more familiar it will feel to
    others.

*   The kernel shall not be monolithic. The goal is to have a 1KB memory
    footprint on 16-bit systems. This is achievable, but in order to do so,
    services like device drivers, filesystems, and network protocols must be
    implemented as programs in user-space. In the case of the microkernel,
    these are represented as servers or daemons which use the kernel's
    inter-process communication functionality to communicate with user-space
    programs. In the case of the exokernel, these are implemented as software
    libraries which the user-space programs link against. Therefore, the only
    systems which exist solely in kernel space are those which implement
    inter-process communication protocols, process scheduling, and a minimized
    form of resource protection. It may even become necessary to minimize some
    of these systems even further.

*   Perhaps a context-switching interrupt? Can be included in libOSes to
    indicate that we are performing some long io process, and can set a
    hardware interrupt to wake the kernel and switch back to this process.

*   Should work on RPis, Arduinos, and the TiVA board.

*   Don't forget to implement a kernel decompressor.

*   Multi-core support? Probably not. At first.

*   Should support femtofs as a ramdisk fs?

*   Should have all necessary binaries contained in the Linux root filesystem,
    which will be as functionally equivalent to the linux versions as possible.

*   (Explore this) - Instead of implementing a file caching system, perhaps
    create a tool which allows a user to explicitly ram cache a file.

*   (Explore this) - Support for XIP of ram-cached files.

*   (Extension of kernel type discussion) - Perhaps we should have a hybrid
    exo-micro-kernel. Some incredibly important things, such as the root
    filesystem and network daemons, can be implemented as servers, other things
    can be libOSes, such as device drivers. (This is just an idea. I see no
    reason why all of these things can't be implemented as libOSes).

*   (Explore this) - Instead of being BIOS based, perhaps we should skip
    straight to being UEFI compliant?

*   (Explore this) System V IPC vs POSIX IPC.

*   Explore POSIX threads.

*   It may be important to simply get it up and running, and then move towards
    system compliance in the future.

*   One tool for attaching block devices, `attach'. Works with real block
    devices and with disk images (*.img files in the sense of hdiutil, OS X).
    Will also have an analog, `detach'. Self-Explanatory. Obviously, some
    devices which implement bridges or interfaces generate an interrupt when
    a downstream device is discovered. This is called `hot-swapping'. There
    should be a kernel parameter which allows you to turn automatic attachment
    off. Either way, these events should be logged in dmesg. The tools `mount'
    and `umount' will also be supported.

*   Observe:
    ibm.com/developerworks/linux/library/l-kernel-logging-apis/index.html
    For a great article on kernel messaging APIs.

*   Should allow for memory protection via an EFI or hypervisor, in the case
    that the device does not have an MMU.

###############################################################################
# FEMTOFS FEATURES
###

*   Dynamically generated inodes (Oooooh, Ahhhhh)

*   Unix permissions support.

*   Limited size? For example, perhaps we should limit ourselves by size.
    If we can get the inode size down to 64 or 128 bytes, that would be great.
    On that note, perhaps we can use a smaller data size to indicate block
    numbers. chars, shorts?

*   Should be able to be implemented as user filesystems, root filesystems, and
    ramdisk filesystems.

*   Support for mounting sub-filesystems anywhere in the host filesystem.

*   Support for mounting filesystems as sub-systems (ext2/4, FAT, JFFS, etc).

###############################################################################
